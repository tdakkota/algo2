package trees

import (
	"github.com/tdakkota/algo2/alg"
	"github.com/tdakkota/algo2/constraints"
)

// BinaryTree represents the binary search tree.
type BinaryTree[K constraints.Ordered, V any] struct {
	root *btnode[K, V]
	size int
}

func NewBinaryTree[K constraints.Ordered, V any]() *BinaryTree[K, V] {
	return new(BinaryTree[K, V])
}

// Min returns the minimal element.
func (m *BinaryTree[K, V]) Min() (v alg.Pair[K, V], ok bool) {
	if min := m.root.min(); min != nil {
		return alg.Two(min.key, min.value), true
	}
	return
}

// Max returns the maximal element.
func (m *BinaryTree[K, V]) Max() (v alg.Pair[K, V], ok bool) {
	if max := m.root.max(); max != nil {
		return alg.Two(max.key, max.value), true
	}
	return
}

// Len returns size of tree.
func (m *BinaryTree[K, V]) Len() int {
	return m.size
}

func (m *BinaryTree[K, V]) find(key K) **btnode[K, V] {
	pn := &m.root
	for *pn != nil {
		switch {
		case alg.Lt((*pn).key, key):
			pn = &(*pn).left
		case alg.Gt((*pn).key, key):
			pn = &(*pn).right
		default:
			return pn
		}
	}
	return pn
}

// Put inserts a new key/value into the map.
// If the key is already present, the value is replaced.
func (m *BinaryTree[K, V]) Put(key K, val V) {
	m.size++
	pn := m.find(key)
	if *pn != nil {
		(*pn).value = val
		return
	}
	*pn = &btnode[K, V]{key: key, value: val}
}

// Get returns the value associated with a key, or the zero value
// if not present. The found result reports whether the key was found.
func (m *BinaryTree[K, V]) Get(key K) (v V, ok bool) {
	pn := m.find(key)
	if *pn == nil {
		return alg.Zero[V](), false
	}
	return (*pn).value, true
}

func (m *BinaryTree[K, V]) delete(key K) (_ bool) {
	if m.root == nil {
		return
	}

	if m.root.key == key {
		tempRoot := &btnode[K, V]{}
		tempRoot.left = m.root
		r := m.root.del(tempRoot, key)
		m.root = tempRoot.left
		return r
	}
	return m.root.left.del(m.root, key) || m.root.right.del(m.root, key)
}

// Delete removes node with given key from tree and returns true if
// deletion is successful.
func (m *BinaryTree[K, V]) Delete(key K) (ok bool) {
	ok = m.delete(key)
	if ok {
		m.size--
	}
	return
}

// Iterate traverse tree in order using given callback.
func (m *BinaryTree[K, V]) iterate(o order, cb func(alg.Pair[K, V]) bool) {
	if m.root != nil {
		m.root.traverse(o, cb)
	}
}

// Iterate traverse tree in order using given callback.
func (m *BinaryTree[K, V]) Iterate(cb func(alg.Pair[K, V]) bool) {
	m.IterateInOrder(cb)
}

// IterateInOrder traverse tree in order using given callback.
func (m *BinaryTree[K, V]) IterateInOrder(cb func(alg.Pair[K, V]) bool) {
	m.iterate(inOrder, cb)
}

// IteratePreOrder traverse tree in pre-order using given callback.
func (m *BinaryTree[K, V]) IteratePreOrder(cb func(alg.Pair[K, V]) bool) {
	m.iterate(preOrder, cb)
}

// IteratePostOrder traverse tree in post-order using given callback.
func (m *BinaryTree[K, V]) IteratePostOrder(cb func(alg.Pair[K, V]) bool) {
	m.iterate(postOrder, cb)
}
