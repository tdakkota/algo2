package trees

import (
	"github.com/tdakkota/algo2/alg"
	"github.com/tdakkota/algo2/constraints"
)

type BinaryTree[K constraints.Ordered, V any] struct {
	root *btnode[K, V]
}

func NewBinaryTree[K constraints.Ordered, V any]() *BinaryTree[K, V] {
	return new(BinaryTree[K, V])
}

type btnode[K constraints.Ordered, V any] struct {
	key K
	value V
	left, right *btnode[K, V]
}

func (m *btnode[K, V]) traverse(cb func(alg.Pair[K, V]) bool) (_ bool) {
	if m.left != nil && !m.left.traverse(cb) {
		return
	}
	
	if !cb(alg.Two(m.key, m.value)) {
		return
	}

	if m.right != nil && !m.right.traverse(cb) {
		return
	}

	return true
}

func (m *BinaryTree[K, V]) find(key K) **btnode[K, V] {
	pn := &m.root
	for *pn != nil {
			switch {
			case alg.Lt((*pn).key, key):
					pn = &(*pn).left
			case alg.Gt((*pn).key, key):
					pn = &(*pn).right
			default:
					return pn
			}
	}
	return pn
}

// Put inserts a new key/value into the map.
// If the key is already present, the value is replaced.
func (m *BinaryTree[K, V]) Put(key K, val V) {
	pn := m.find(key)
	if *pn != nil {
			(*pn).value = val
			return
	}
	*pn = &btnode[K, V]{key: key, value: val}
}

// Get returns the value associated with a key, or the zero value
// if not present. The found result reports whether the key was found.
func (m *BinaryTree[K, V]) Get(key K) (v V, ok bool) {
	pn := m.find(key)
	if *pn == nil {
			return alg.Zero[V](), false
	}
	return (*pn).value, true
}

func (m *BinaryTree[K, V]) Iterate(cb func(alg.Pair[K, V]) bool) {
	if m.root != nil {
		m.root.traverse(cb)
	}
}