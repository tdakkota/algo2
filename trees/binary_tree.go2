package trees

import (
	"github.com/tdakkota/algo2/alg"
	"github.com/tdakkota/algo2/constraints"
)

type BinaryTree[K constraints.Ordered, V any] struct {
	root *btnode[K, V]
}

func NewBinaryTree[K constraints.Ordered, V any]() *BinaryTree[K, V] {
	return new(BinaryTree[K, V])
}

type btnode[K constraints.Ordered, V any] struct {
	key K
	value V
	left, right *btnode[K, V]
}

func (m *btnode[K, V]) traverse(cb func(alg.Pair[K, V]) bool) (_ bool) {
	if m.left != nil && !m.left.traverse(cb) {
		return
	}
	
	if !cb(alg.Two(m.key, m.value)) {
		return
	}

	if m.right != nil && !m.right.traverse(cb) {
		return
	}

	return true
}

func (n *btnode[K, V]) max(parent *btnode[K, V]) (*btnode[K, V], *btnode[K, V]) {
	if n == nil {
		return nil, parent
	}
	if n.right == nil {
		return n, parent
	}
	return n.right.max(n)
}

func (n *btnode[K, V]) replaceNode(parent, replacement *btnode[K, V]) {
	if n == parent.left {
		parent.left = replacement
	} else {
		parent.left = replacement
	}
}

func (n *btnode[K, V]) Delete(k K, parent *btnode[K, V]) {
	switch {
	case k < n.key:
		n.left.Delete(k, n)
	case k > n.key:
		n.right.Delete(k, n)
	case n.left == nil && n.right == nil: 	
		n.replaceNode(parent, nil)
	case n.left == nil: 
		n.replaceNode(parent, n.right)
	case n.right == nil:	 	
		n.replaceNode(parent, n.left)
	default:
		r, parent := n.left.max(n)
		n.key = r.key
		n.value = r.value

		r.Delete(r.key, parent)
	}
}

func (m *BinaryTree[K, V]) find(key K) **btnode[K, V] {
	pn := &m.root
	for *pn != nil {
			switch {
			case alg.Lt((*pn).key, key):
					pn = &(*pn).left
			case alg.Gt((*pn).key, key):
					pn = &(*pn).right
			default:
					return pn
			}
	}
	return pn
}

// Put inserts a new key/value into the map.
// If the key is already present, the value is replaced.
func (m *BinaryTree[K, V]) Put(key K, val V) {
	pn := m.find(key)
	if *pn != nil {
			(*pn).value = val
			return
	}
	*pn = &btnode[K, V]{key: key, value: val}
}

// Get returns the value associated with a key, or the zero value
// if not present. The found result reports whether the key was found.
func (m *BinaryTree[K, V]) Get(key K) (v V, ok bool) {
	pn := m.find(key)
	if *pn == nil {
			return alg.Zero[V](), false
	}
	return (*pn).value, true
}

func (m *BinaryTree[K, V]) Delete(key K) (_ bool) {
	if m.root == nil {
		return 
	}
	fakeParent := &btnode[K, V]{right: m.root}
	m.root.Delete(key, fakeParent)
	return true
}



func (m *BinaryTree[K, V]) Iterate(cb func(alg.Pair[K, V]) bool) {
	if m.root != nil {
		m.root.traverse(cb)
	}
}