package cache

import "github.com/tdakkota/algo2/list"

type Element = list.Element
type List = list.LinkedList

type lfuCacheNode[K, V any] struct {
	key    K
	value  V
	parent *Element[FreqNode[K, V]]
}

func evictNode[K, V any](e *Element[lfuCacheNode[K, V]]) {
	// remove the cache node from the linkedList
	// remove the freqNode(parent) if it is empty
	// do nothing to the map
	node := e.Value
	curFreqNode := node.parent.Value
	curFreqNode.list.Remove(e)

	if curFreqNode.list.Len() == 0 {
		removeFreqNode(node.parent)
	}
}

func moveAddOneFreq[K, V any](e *Element[lfuCacheNode[K, V]], key K, value V) *Element[lfuCacheNode[K, V]] {
	var newFreqNode *Element[FreqNode[K, V]]
	n := e.Value
	curFreqNode := n.parent

	if next := curFreqNode.Next(); next != nil && next.Value.freq == (curFreqNode.Value.freq+1) {
		newFreqNode = next
	} else {
		newFreqNode = curFreqNode.List().InsertAfter(NewFreqNode[K, V](curFreqNode.Value.freq+1), curFreqNode)
	}

	newCacheNode := lfuCacheNode[K, V]{
		key:    key,
		value:  value,
		parent: newFreqNode,
	}
	listElement := newFreqNode.Value.list.PushFront(newCacheNode)
	evictNode(e)

	return listElement
}

type FreqNode[K, V any] struct {
	freq int
	list *List[lfuCacheNode[K, V]]
}

func removeFreqNode[K, V any](node *Element[FreqNode[K, V]]) {
	if node.Value.freq == 0 {
		panic("should not remove the head")
	}
	node.List().Remove(node)
}

func NewFreqNode[K, V any](freq int) FreqNode[K, V] {
	return FreqNode[K, V]{
		freq: freq,
		list: list.NewLinkedList[lfuCacheNode[K, V]](),
	}
}

type LFUCache[K comparable, V any] struct {
	size     int
	capacity int
	cache    map[K]*Element[lfuCacheNode[K, V]]
	lfuHead  *List[FreqNode[K, V]]
}

func NewLFUCache[K comparable, V any](capacity int) *LFUCache[K, V] {
	return & LFUCache[K, V]{
		capacity: capacity,
		cache:    make(map[K]*Element[lfuCacheNode[K, V]], capacity),
		lfuHead:  list.NewLinkedList[FreqNode[K, V]](),
	}
}

func (l *LFUCache[K, V]) Get(key K) (v V, ok bool) {
	if found, ok := l.cache[key]; ok {
		newCacheNode := moveAddOneFreq(found, key, found.Value.value)
		l.cache[key] = newCacheNode
		return found.Value.value, true
	}
	return
}

func (l *LFUCache[K, V]) Put(key K, value V) {
	if l.capacity == 0 {
		return
	}

	if found, ok := l.cache[key]; ok {
		l.cache[key] = moveAddOneFreq(found, key, value)
	} else {
		if l.size >= l.capacity {
			lfuNode := l.lfuHead.Front().Value.list.Back()
			delete(l.cache, lfuNode.Value.key)
			evictNode(lfuNode)
		} else {
			l.size++
		}

		var oneFreqNode *Element[FreqNode[K, V]]
		if next := l.lfuHead.Front(); next != nil && next.Value.freq == 1 {
			oneFreqNode = next
		} else {
			oneFreqNode = l.lfuHead.PushFront(NewFreqNode[K, V](1))
		}

		newCacheNode := lfuCacheNode[K, V]{
			key:    key,
			value:  value,
			parent: oneFreqNode,
		}
		l.cache[key] = oneFreqNode.Value.list.PushFront(newCacheNode)
	}

}

